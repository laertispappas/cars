RATING = 0 # Holds the index of rating in user preference array
OPTIMUM = 3.5 # Optimum rating for recommendation > 3.5

"""
TBD: broad classes of prediction accuracy measures; measuring
the accuracy of ratings predictions, measuring the accuracy of usage predictions,
and measuring the accuracy of rankings of items.

Measuring Ratings Prediction Accuracy:
    - Root Mean Squared Error (RMSE)
    - Mean Absolute Error (MAE)
    - Normalized RMSE (NMRSE)
    - Average RMSE
Measuring Usage Prediction:
    - Precision
    - Recall
    - False Positive Rate
    - F-measure
    - Area Under the ROC Curve (AUC)
    - Precision-Recall and ROC for Multiple Users
Ranking Measures
    - Normalized Distance based Performance Measure (NDPM)
    - average precision (AP) correlation
    - Utility-Based Ranking


"""


def precision(user, recommendations, udb, all_udb):
    """
    recommendations: generated by get_recommendations
    udb: test udb

    precision = #tp / #tp + #fp
    where:
        #tp => Recommended and Used
        #fp => Recommended and not Used
    """
    all = len(recommendations) + 0.00000000000000000001 # === tp + fp
    tp = 0
    fp = 0
    for (rec_rating, rec_movie) in recommendations:
        for movie in udb[user].keys():
            if movie == rec_movie and udb[user][movie][RATING] >= OPTIMUM:
                tp += 1
                break
        if rec_movie not in udb[user].keys():
            fp += 1

    print "User: ", user
    print "\t**TP, all***"
    print "\t", tp, ",", all
    print "\t**End TP, all***"
    print "\t fp= ", fp
    return tp/float(tp + fp + 0.00000000000000000001)

def recall(user, recommendations, udb):
    """
    :param user: Target user
    :param recommendations: recommendation list generated for target user
    :param udb: test dataset
    :return:


    recall = #tp / #tp + #fn
    where:
        #tp => Recommended and Used
        #fn => Not recommended but Used
    """
    tp = 0
    fn = 0
    good_movies = 0

    for movie in udb[user].keys():
        if udb[user][movie][RATING] >= OPTIMUM:
            good_movies += 1
            found = False
            for (x, y) in recommendations:
                if movie == y:
                    tp += 1
                    found = True
                    break
            if not found:
                fn += 1

    print "**\ttp, fn***"
    print "\t", tp, fn
    print "**\tEnd Recall***"
    return tp/float(tp + fn)

def f1score(precision, recall):
    if precision + recall == 0:
        return 0
    return 2 * (precision * recall)/(precision + recall)