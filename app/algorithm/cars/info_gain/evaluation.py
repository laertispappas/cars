RATING = 0 # Holds the index of rating in user preference array
OPTIMUM = 3.5 # Optimum rating for recommendation > 3.5

"""
TBD: broad classes of prediction accuracy measures; measuring
the accuracy of ratings predictions, measuring the accuracy of usage predictions,
and measuring the accuracy of rankings of items.

Measuring Ratings Prediction Accuracy:
    - Root Mean Squared Error (RMSE)
    - Mean Absolute Error (MAE)
    - Normalized RMSE (NMRSE)
    - Average RMSE
Measuring Usage Prediction:
    - Precision
    - Recall
    - False Positive Rate
    - F-measure
    - Area Under the ROC Curve (AUC)
    - Precision-Recall and ROC for Multiple Users
Ranking Measures
    - Normalized Distance based Performance Measure (NDPM)
    - average precision (AP) correlation
    - Utility-Based Ranking


"""


def precision(user, recommendations, udb, all_udb):
    """
    recommendations: generated by get_recommendations
    udb: test udb

    precision = #tp / #tp + #fp
    where:
        #tp => Recommended and Used
        #fp => Recommended and not Used
    """
    all = len(recommendations) + 0.00000000000000000001 # === tp + fp
    tp = 0
    fp = 0
    for (rec_rating, rec_movie) in recommendations:
        for movie in udb[user].keys():
            if movie == rec_movie and (round(rec_rating) - 1 <= udb[user][movie][RATING] <= round(rec_rating) + 1):
                tp += 1
        if rec_movie not in udb[user].keys():
            fp += 1

    print "User: ", user
    print "\t**TP, all***"
    print "\t", tp, ",", all
    print "\t**End TP, all***"
    print "\t fp= ", fp
    return tp/float(tp + fp + 0.00000000000000000001)

def recall(user, recommendations, udb):
    """
    :param user:
    :param recommendations:
    :param udb:
    :return:


    recall = #tp / #tp + #fn
    where:
        #tp => Recommended and Used
        #fn => Not recommended but Used
    """
    tp = 0
    good_movies = 0
    for movie in udb[user].keys():
        if OPTIMUM + 1 >= udb[user][movie][RATING] >= OPTIMUM - 1:
            good_movies += 1
            for (x, y) in recommendations:
                if movie == y:
                    tp += 1

    print "**\tTP, good movies***"
    print "\t", tp, good_movies
    print "**\tEnd TP, good movies***"
    return tp/float(good_movies)

def f1score(precision, recall):
    if precision + recall == 0:
        return 0
    return 2 * (precision * recall)/(precision + recall)