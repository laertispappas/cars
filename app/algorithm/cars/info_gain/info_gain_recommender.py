from app.algorithm.cars.context_recommender import ContextRecommender
from app.dataset.data_object import DataObject
from app.dataset.loader import AutoVivification
import numpy

import os

from app.utils.similarities import sim_euclidean

RATING = 0 # Holds the index of rating in user preference array
OPTIMUM = 3.5 # Optimum rating for recommendation > 3.5

def precision(user, recommendations, udb):
    """
    recommendations: generated by get_recommendations
    udb: test udb
    """
    all = len(recommendations)
    tp = 0
    for (x, y) in recommendations:
        for movie in udb[user].keys():
            if movie == y and (round(x) - 1 <= udb[user][movie][RATING] <= round(x) + 1):
                tp += 1
    #print tp, all
    return tp/float(all)

def recall(user, recommendations, udb):
    tp = 0
    good_movies = 0
    for movie in udb[user].keys():
        if OPTIMUM + 1 >= udb[user][movie][RATING] >= OPTIMUM - 1:
            good_movies += 1
            for (x, y) in recommendations:
                if movie == y:
                    tp += 1
    return tp/float(good_movies)

def f1score(precision, recall):
    return 2 * (precision * recall)/(precision + recall)

class InfoGainRecommender(ContextRecommender):
    def init_model(self):
        self.userprofile = self.__build_user_profile()
    def build_model(self):
        pass

    def evaluate(self, user):
        train_udb, test_udb = self.__remove_for_testing(self.dao.users, user)
        recs = self.__user_cf_recs(train_udb, user)

        precision_train, recall_train = precision(user, recs, test_udb), recall(user, recs, test_udb)
        print "CF precision: ", precision_train
        print "CF recall: ", recall_train
        print "CF f1Score: ", f1score(precision_train, recall_train)
        print "CF total: ", len(recs)

        # Context - Value tuple
        filters = [(8, 2), (5, 1), (9, 2), (10, 2), (6, 1), (16, 1), (13, 1), (7, 1), (14, 1), (12, 1), (11, 1)]
        filter_recs = self.__contextual_filter(self.dao.users, self.userprofile, user, recs, filters)

        precision_test, recall_test = precision(user, filter_recs, test_udb), recall(user, filter_recs, test_udb)
        print precision_test, recall_test, len(filter_recs)
        print "****"
        print "Filtered precision: ", precision_test
        print "Filtered recall: ", recall_test
        print "Filtered f1Score: ", f1score(precision_test, recall_test)
        print "Filtered total: ", len(filter_recs)

    # Returns top recommendations for the given user.
    def top_recommendations(self, user):
        recs = self.__user_cf_recs(self.dao.users, user)

        # Context - Value tuple
        filters = [(8, 2), (5, 1), (9, 2), (10, 2), (6, 1), (16, 1), (13, 1), (7, 1), (14, 1), (12, 1), (11, 1)]
        filter_recs = self.__contextual_filter(self.dao.users, self.userprofile, user, recs, filters)
        return filter_recs

    # Gets recommendations for a person by using a weighted average
    # of every other user's rankings User based CF
    #
    def __user_cf_recs(self, prefs, person, similarity=sim_euclidean):
        totals = {}
        simSum = {}
        for other in prefs:
            if other == person: continue
            sim = similarity(prefs, person, other)
            if sim <= 0: continue
            for item in prefs[other]:
                if item not in prefs[person] or prefs[person][item][RATING] == 0:
                    totals.setdefault(item, 0)
                    totals[item] += prefs[other][item][RATING] * sim
                    # Similarity sums
                    simSum.setdefault(item, 0)
                    simSum[item] += sim
        rankings = [(total / simSum[item], item) for item, total in totals.items()]
        # Testing: Checking if ratings match with that in dataset
        rankings.sort()
        rankings.reverse()
        return rankings

    # TODO Add Item Based CF

    # Private Methods
    """
    Function
    ---------------------
    __build_user_profile
    ---------------------
    Returns
        Builds a dictionary of User Profiles by parsing through the info gain file
        => {user1: [c1, c2, c5, c6]}
    """
    def __build_user_profile(self, filename='InfoGainResults.txt'):
        dir = os.path.dirname(__file__)
        src_path = os.path.join(dir, filename)

        userprofile = {}
        with open(src_path) as f:
            for line in f:
                line = line.strip()
                row = line.split(',')
                key, val = eval(row[0]), [DataObject.feature_dict[x] for x in row[1:]]
                userprofile[key] = val
        return userprofile

    # Given udb datastore return 1/3 as a test dataset and 2/3 as train dataset
    def __remove_for_testing(self, udb, user):
        limit = int(len(udb[user]) / 3.0)
        test_udb = AutoVivification()
        import copy;
        train_udb, i = copy.deepcopy(udb), 0
        for movie in udb[user]:
            test_udb[user][movie] = train_udb[user][movie]
            del (train_udb[user][movie])
            i += 1
            if i > limit: break
        # print len(train_udb[user]), len(test_udb[user]), len(udb[user])
        return train_udb, test_udb

    """
    Function
    __contextual_filter
    -----------------
        udb: user datastructure
            => { user_id: { item_id: [rating,age,sex,city,country, c1, c2, ................, c12] } }
        profiles: User Profile built based on Information gain of Contextual attributes
            => {user1: [c1, c2, c5, c6]}
        user: Target User
            => 15
        recommendations: Recommendations generated by a traditions recommender
            => [(rating, item_id)]
        filters: User entered Contextual Attributes
            =>  [(8, 2), (5, 1), (9, 2), (10, 2), (6, 1), (16, 1), (13, 1), (7, 1), (14, 1), (12, 1), (11, 1)]
    Returns
        User post filtered recommendations
            => [(rating, movie), ...]
    """
    def __contextual_filter(self, udb, profiles, user, recommendations, filters):
        filtered_recs = []
        for rating, movie in recommendations:
            if rating >= OPTIMUM:
                for context, value in filters:
                    if context in profiles[user]:
                        avg = float(self.__find_max_context(movie, context, udb))
                        if avg == value and (rating, movie) not in filtered_recs:
                            filtered_recs.append((rating, movie))
        return filtered_recs

    def __find_max_context(self, movie, context, udb):
        list_context = []
        for user in udb:
            if udb[user][movie][context] != {} and udb[user][movie][RATING] >= OPTIMUM:
                value = udb[user][movie][context]
                if type(value) == numpy.float64:
                    list_context.append(udb[user][movie][context])
        if len(list_context) > 1:
            m = max(list_context)
        else:
            m = -1
        return m